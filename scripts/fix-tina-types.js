#!/usr/bin/env node
/**
 * Post-build script to fix Tina generated types
 * Removes @ts-nocheck and replaces 'any' types with proper TypeScript types
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

const TYPES_FILE_PATH = join(process.cwd(), 'tina', '__generated__', 'types.ts');

function fixTinaTypes() {
  try {
    console.log('üîß Fixing Tina generated types...');
    
    let content = readFileSync(TYPES_FILE_PATH, 'utf-8');
    let changes = 0;

    // Remove @ts-nocheck directive
    if (content.includes('//@ts-nocheck')) {
      content = content.replace(
        '//@ts-nocheck\n  // DO NOT MODIFY THIS FILE. This file is automatically generated by Tina',
        '// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina\n// Note: @ts-nocheck removed to enable proper type checking'
      );
      changes++;
      console.log('  ‚úÖ Removed @ts-nocheck directive');
    }

    // Add TinaRichTextContent type if not present
    if (!content.includes('export type TinaRichTextContent')) {
      content = content.replace(
        '// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina\n// Note: @ts-nocheck removed to enable proper type checking',
        '// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina\n// Note: @ts-nocheck removed to enable proper type checking\n\n/** Tina rich text content type */\nexport type TinaRichTextContent = Record<string, unknown> | string | null;'
      );
      changes++;
      console.log('  ‚úÖ Added TinaRichTextContent type definition');
    }

    // Fix Reference and JSON scalar types
    content = content.replace(
      /Reference: \{ input: any; output: any; \}/g,
      'Reference: { input: string | Record<string, unknown>; output: string | Record<string, unknown>; }'
    );
    content = content.replace(
      /JSON: \{ input: any; output: any; \}/g,
      'JSON: { input: Record<string, unknown> | string | number | boolean | null; output: Record<string, unknown> | string | number | boolean | null; }'
    );

    // Fix body field types
    const bodyTypeRegex = /body\?\: any \| null/g;
    if (content.match(bodyTypeRegex)) {
      content = content.replace(bodyTypeRegex, 'body?: TinaRichTextContent');
      changes++;
      console.log('  ‚úÖ Fixed body field types');
    }

    // We don't need GraphQL DocumentNode import since we use string type

    // Fix function parameter types
    content = content.replace(
      /doc: any,\s*vars\?: any,/g,
      'doc: string,\n    vars?: Record<string, unknown>,'
    );
    content = content.replace(
      /\) => Promise<any> =/g,
      ') => Promise<Record<string, unknown>> ='
    );

    // Fix TinaClient generic type usage
    content = content.replace(
      /client: TinaClient,/g,
      'client: TinaClient<any>,'
    );

    // Fix function signature in generateRequester
    const functionSignatureRegex = /const requester: \(\s*doc: string,\s*vars\?: Record<string, unknown>,\s*options\?: \{[^}]+\},\s*client\s*\) => Promise<Record<string, unknown>>/;
    if (functionSignatureRegex.test(content)) {
      content = content.replace(
        functionSignatureRegex,
        'const requester: (doc: string, vars?: Record<string, unknown>, options?: { branch?: string; fetchOptions?: Omit<Parameters<typeof fetch>[1], "body" | "method">; }) => Promise<Record<string, unknown>>'
      );
      changes++;
      console.log('  ‚úÖ Fixed function signature');
    }

    // Fix Requester type to use string instead of DocumentNode
    content = content.replace(
      /export type Requester<C= \{\}> = <R, V>\(doc: DocumentNode, vars\?: V, options\?: C\) => Promise<R>/,
      'export type Requester<C= {}> = <R, V>(doc: string, vars?: V, options?: C) => Promise<R>'
    );

    // Fix function signature to match Requester type
    content = content.replace(
      /const requester: \(\s*doc: string,\s*vars\?: Record<string, unknown>,\s*options\?: \{[^}]+\}\s*\) => Promise<Record<string, unknown>>/,
      'const requester: Requester<{ branch?: string; fetchOptions?: Omit<Parameters<typeof fetch>[1], "body" | "method">; }>'
    );

    // Fix client.request call to handle optional parameters properly
    content = content.replace(
      /const data = await client\.request\(\{\s*query: doc,\s*variables: vars,\s*url,\s*\}, options\)/,
      'const data = await client.request({ query: doc, variables: vars, url }, options)'
    );

    // Remove the conflicting GraphQL import since we're using string type
    content = content.replace(
      /import type \{ DocumentNode as GraphQLDocumentNode \} from "graphql";\n/,
      ''
    );

    if (changes > 0) {
      writeFileSync(TYPES_FILE_PATH, content, 'utf-8');
      console.log(`üéâ Fixed ${changes} type issues in Tina generated types`);
    } else {
      console.log('‚ú® Tina types are already properly typed');
    }

  } catch (error) {
    console.error('‚ùå Error fixing Tina types:', error.message);
    process.exit(1);
  }
}

// Run the fix
fixTinaTypes();